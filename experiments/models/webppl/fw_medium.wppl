

var get_initial_dist = function(a, b, edges, max) {
  if (a == b) {
    return 0;
  }
  else if (edges.length == 0) {
    return max;
  }
  else {
    var cur_edge = edges[0];
    if ((cur_edge[0] == a && cur_edge[1] == b) || (cur_edge[1] == a && cur_edge[0] == b)){
      return cur_edge[2];
    }
    else{
      return get_initial_dist(a, b, edges.slice(1), max);
    }
  }
}

var gen_initial_dists_helper = function(j, i, n, edges, max) {
  if(j == n) {
    return [];
  }
  else {
    return [get_initial_dist(i, j, edges, max)].concat(gen_initial_dists_helper(j+1, i, n, edges, max));
  }
}

var gen_initial_dists = function(i, n, edges, max) {
  if (i == n) {
    return [];
  }
  else {
    return [gen_initial_dists_helper(0, i, n, edges, max)].concat(gen_initial_dists(i+1, n, edges, max));
  }
}

var update_dists_helper = function(j, i, k, n, prev_dist, current_dist, current_dist_row) { 
  if (j == n) {
    return [];
  }
  else {
    var utd_table = current_dist.concat([current_dist_row]);
    var entry_one = k > j ? prev_dist[i][k] : utd_table[i][k];
    var entry_two = k > i ? prev_dist[k][j] : utd_table[k][j];
    var sum = entry_one + entry_two;
    var old_num = prev_dist[i][j]
    var new_num = (old_num > sum) ? sum : old_num;
    
    var update = current_dist_row.concat([new_num]);
    return [new_num].concat(update_dists_helper(j+1, i, k, n, prev_dist, current_dist, update));
  }
}

var update_dists = function(i, k, n, prev_dist, current_dist) {
  if (i == n) {
    return []; 
  }
  else {
    var new_row = update_dists_helper(0, i, k, n, prev_dist, current_dist, []);
    return [new_row].concat(update_dists(i+1, k, n, prev_dist, current_dist.concat([new_row])));
  }
}


var floyd_warshall_loop = function(k, n, start_dist) { 
  if (k == n) { 
    return start_dist;
  }
  else {
    var new_dist = update_dists(0, k, n, start_dist, []);
    return floyd_warshall_loop(k+1, n, new_dist);
  }
}
var get_edge_weights = function(edges) {
  if (edges.length == 0) { 
    return [];
  }
  else {
    var cur_edge = edges[0];
    var weight =  randomInteger(2*(cur_edge[1]-cur_edge[0]))+1;
    return [[cur_edge[0], cur_edge[1], weight]].concat(get_edge_weights(edges.slice(1)))
  }
}

var main = function(){
  var n = 6;
  var max = n*n*3;
  var edges = 
      [[0, 1, randomInteger(2)+1],
    [0, 2, randomInteger(4)+1],
    [0, 5, randomInteger(10)+1],
    [1, 2, randomInteger(2)+1],
    [1, 4, randomInteger(6)+1],
    [2, 4, randomInteger(4)+1],
    [3, 4, randomInteger(2)+1],
    [4, 5, randomInteger(2)+1]];
  var table = gen_initial_dists(0, n, edges, max);
  
  var new_table = floyd_warshall_loop(0, n, table);
  return new_table[0][5];
};

timeit(function(){Infer({method:'enumerate',model:main}).getDist(0)}).runtimeInMilliseconds
