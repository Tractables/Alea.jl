
def step(delta:Z) :Z{
    d := (0:Z);
    if (delta < 5) && (delta > -5) {
        return 0;
    } 
    else {
        if(delta < 0) {
            if (delta > -25) {
                return delta + uniformInt(-10, 10);
            }
            else if (delta > -50) {
                return delta + uniformInt(-20, 20);
            }
            else if (delta > -100) {
                return delta + uniformInt(-50, 50);
            }
            else {
                return delta + uniformInt(-100, 100);
            }
        }
        else {
            if (delta <25) {
                return delta + uniformInt(-10, 10);
            }
            else if (delta <50) {
                return delta + uniformInt(-20, 20);
            }
            else if (delta <100) {
                return delta + uniformInt(-50, 50);
            }
            else {
                return delta + uniformInt(-100, 100);
            }
        }
    }
    return 0;
}

def takeStep(curValue:Z, d:Z) {
    newCur := curValue + d;
    if (newCur > 500)
    {
        newCur = 500;
    }
    if (newCur < 1)
    {
        newCur = 1;
    }
    return newCur;
}

def main() {
    curValue:Z := uniformInt(1, 500);
    tgtValue:Z := uniformInt(1, 500);

    delta:Z := (tgtValue - curValue);
    d := (0:Z);
    
    d = step(delta);
    curValue = takeStep(curValue, d);
    delta = tgtValue - curValue;
    
    return (delta < 5) && (delta > -5)
}

